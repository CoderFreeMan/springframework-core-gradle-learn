# 依赖注入
## 基于构造函数的依赖注入
## 基于 Setter 的依赖注入
## Constructor-based vs setter-based
&emsp; &emsp; 基于构造函数的DI和基于 setter 的DI可以混合使用，因此将构造函数用于强制性依赖项，将 setter 方法用于可选性依赖项是一个很好的经验法则。请注意，可以在 setter 方法上使用 @Required 注解，以使该属性称为必须的依赖项，但是，最好使用带有参数的程序验证的构造函数注入。

&emsp; &emsp; Spring 团队通常提倡使用构造函数注入，因为它可以让你将应用程序组件实现为不可变对象，并确保不存在必须的依赖项为 null。此外注入构造函数的组件始终以完全初始化的状态返回给客户端(调用)代码。附带说明一下，大量的带有参数的构造函数是一种不好的代码味道，这表明该类可能承担了该多的职责，应进行重构以更好地解决关注点分离问题。

&emsp; &emsp; Setter 注入主要仅用于可以在类中分配合理的默认值的可选依赖项。否则，必须在代码使用依赖项的任何地方执行非空检查。setter 注入的一个好处是 setter 方法可使该类的对象在以后重新配置或重新注入。因此，通过 [JMX MBean](https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/integration.html#jmx) 进行管理是用于 setter 注入的引人注目的用例。

&emsp; &emsp; 使用最合适特定类的DI风格。有时在处理你没有源代码的第三方类时，将为你做出选择。例如，如果第三方类未公开任何 setter 方法，则构造函数注入可能是DI的唯一可用形式。

## 循环依赖

如果主要使用构造函数注入，则可能会创建无法解决的循环依赖问题。  

例如：类A通过构造函数注入需要类B的实例，而类B通过构造函数注入需要类A的实例。如果你将A类和B类的bean配置为互相注入，则 Spring IoC 容器会在运行时检查到此循环依赖，并抛出 BeanCurrentlyIncreationException。  

一种可能的解决方案是编辑某些类的源代码，这些类的源代码由设置者而不是构造函数来配置。或者，避免构造函数注入，而仅使用setter注入。换句话说，尽管不建议这样做，但是可以使用setter注入配置的循环依赖关系。  

与典型情况(没有循环依赖关系)不同，bean A 和 bean B之间的循环依赖关系迫使其中一个bean在完全初始化之前被注入另一个bean(经典的先有鸡还是先有蛋的问题)。  

